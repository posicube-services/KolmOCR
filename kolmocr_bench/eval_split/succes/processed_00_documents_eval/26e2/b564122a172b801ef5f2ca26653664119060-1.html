<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Document</title>
<style>
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.6;
  color: #333;
}

.document {
  max-width: 100%;
  padding: 20px;
}

.document.columns-2 {
  column-count: 2;
  column-gap: 2rem;
}

.document.columns-3 {
  column-count: 3;
  column-gap: 2rem;
}

@media print {
  body, .document, .block {
    page-break-inside: avoid;
  }
}

table,
table.data-table {
  border-collapse: collapse;
  width: 100%;
  margin: 1rem 0;
  break-inside: avoid;
  border: 1px solid #999;
}

table th,
table td,
table.data-table th,
table.data-table td {
  border: 1px solid #999;
  padding: 8px 12px;
  text-align: left;
}

table th,
table.data-table th {
  background-color: #f5f5f5;
  font-weight: bold;
  border: 1px solid #666;
}

table tbody tr:nth-child(even),
table.data-table tbody tr:nth-child(even) {
  background-color: #f9f9f9;
}

table tbody tr:hover,
table.data-table tbody tr:hover {
  background-color: #f0f0f0;
}

.math-display {
  display: block;
  margin: 1rem 0;
  overflow-x: auto;
}

.math-inline {
  display: inline;
}

.block {
  margin: 1rem 0;
  width: fit-content;
}

ul, ol {
  margin: 0.5rem 0;
  padding-left: 2rem;
}

figure {
  margin: 1rem 0;
  text-align: center;
}

figure img {
  max-width: 100%;
  height: auto;
}

figcaption {
  font-style: italic;
  color: #666;
  margin-top: 0.5rem;
}

h1 {
  font-size: 2rem;
  margin: 1.5rem 0 0.5rem 0;
  border-bottom: 2px solid #ddd;
  padding-bottom: 0.3rem;
}

h2 {
  font-size: 1.5rem;
  margin: 1.3rem 0 0.4rem 0;
}

h3 {
  font-size: 1.2rem;
  margin: 1.1rem 0 0.3rem 0;
}

h4, h5, h6 {
  margin: 1rem 0 0.3rem 0;
}

p {
  margin: 0.5rem 0;
}
</style>
<script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: false,
        processEnvironments: true
    },
    options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    svg: {
        fontCache: 'global'
    },
    startup: {
        ready: () => {
            MathJax.startup.defaultReady();
            MathJax.startup.promise.then(() => {
                console.log('MathJax initial rendering complete');
                // Force re-typeset after DOM is fully loaded
                MathJax.typesetPromise().then(() => {
                    console.log('MathJax re-typeset complete');
                }).catch((err) => console.log('MathJax typeset error:', err));
            });
        }
    }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<div class="document columns-2" style="column-count: 2; column-gap: 1.5rem;">
  <div class="block" data-id="b001" data-bbox="35,29,630,735">
    <pre><code class="language-markdown">cpp

void kruskal(BasicGraph&amp; graph, BasicGraph&amp; mst) {
    // 먼저, 그래프를 복사하고 간선을 제거합니다.
    // 이렇게 하면 나중에 MST 간선을 추가할 수 있습니다.
    mst = graph;
    mst.clearEdges();

    // 각 정점을 &#x27;클러스터&#x27;에 넣습니다. 초기에는 각 정점이 자신만 포함합니다.
    Map&lt;Vertex*, Set&lt;Vertex&gt;*&gt; clusters;
    Set&lt;Vertex*&gt; allVertices = graph.getVertexSet();
    Vector&lt;Set&lt;Vertex&gt;*&gt; allSets; // 나중에 메모리 해제를 위해
    for (Vertex* v : allVertices) {
        Set&lt;Vertex&gt;* set = new Set&lt;Vertex&gt;();
        set-&gt;add(v);
        clusters[v] = set;
        allSets.add(set);
    }

    // 모든 간선을 가중치에 따라 우선순위 큐에 넣습니다.
    PriorityQueue&lt;Edge&gt; pq;
    Set&lt;Edge*&gt; allEdges = graph.getEdgeSet();
    for (Edge* edge : allEdges) {
        pq.enqueue(edge, edge-&gt;cost);
    }

    // 반복적으로 최소 가중치 간선을 큐에서 꺼내서 MST에 추가합니다.
    // 만약 간선의 끝점이 이미 연결되어 있지 않다면.
    Set&lt;Edge*&gt; mstEdges;
    while (!pq.isEmpty()) {
        Edge* e = pq.dequeue();
        Set&lt;Vertex&gt; set1 = clusters[e-&gt;start];
        Set&lt;Vertex&gt; set2 = clusters[e-&gt;finish];
        if (set1 != set2) {
            mstEdges.add(e);
            // 두 집합을 합칩니다.
            set1-&gt;addAll(*set2);
            for (Vertex* v : *set1) {
                Set&lt;Vertex&gt; setv = clusters[v];
                if (setv != set1) {
                    clusters[v] = set1;
                }
            }
        }
    }

    // MST 간선을 그래프에 추가합니다.
    // 직접 간선 포인터를 추가할 수는 없으므로
    // 나중에 메모리 해제하는 데 문제가 생길 수 있습니다.
    for (Edge* edge : mstEdges) {
        mst.addEdge(edge-&gt;start-&gt;name, edge-&gt;end-&gt;name, edge-&gt;cost, false);
    }
}</code></pre>
  </div>
  <div class="block" data-id="b002" data-bbox="35,776,61,20">
    <h3>Table</h3>
  </div>
  <div class="block" data-id="b003" data-bbox="35,808,248,86">
    <table class="data-table">
      <thead>
        <tr><th>Column 1</th><th>Column 2</th></tr>
      </thead>
      <tbody>
        <tr><td>Cell A</td><td>Cell B</td></tr>
        <tr><td>Cell C</td><td>Cell D</td></tr>
      </tbody>
    </table>
  </div>
  <div class="block" data-id="b004" data-bbox="35,905,297,20">
    <h3>Image with Bounding Box</h3>
  </div>
  <div class="block" data-id="b005" data-bbox="35,936,1068,17">
    <p>&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...&quot;/&gt; &lt;!-- Normalization: [0,0,1000,1000] --&gt;</p>
  </div>
</div>
</body>
</html>